// Generated by CoffeeScript 2.1.1
var When, _, _B, body, comment, div, doctype, execP, fixPathsForNode, fsp, h1, h2, h3, h4, head, html, isWatching, l, li, link, meta, minUrequireVersion, p, pkg, raw, render, renderable, script, spawn, specRunner, style, table, td, teacup, th, tidyP, title, tr, ul, upath,
  indexOf = [].indexOf;

minUrequireVersion = "0.7.0-beta.27";

_B = require('uberscore');

_ = require('lodash');

l = new _B.Logger('urequire-ab-specrunner');

_.mixin((require('underscore.string')).exports());

upath = require('upath');

fsp = require('fs-promise'); // uses fs-extra as well

When = require('./whenFull');

tidyP = When.node.lift(require('htmltidy').tidy);

spawn = require('child_process').spawn;

execP = When.node.lift(require("child_process").exec);

({renderable, render, html, doctype, head, link, meta, script, p, body, title, h1, h2, h3, h4, div, comment, ul, li, raw, table, tr, td, th, style} = teacup = require('teacup'));

pkg = JSON.parse(fsp.readFileSync(__dirname + '/../../package.json')); // this is `urequire-ab-specrunner` 's package.json

isWatching = false;

// @todo: modulerize as an extendible class, so other test frameworks can be based on it!
module.exports = specRunner = function(err, specBB, options) {
  var _title, bb, chai_path, generateAndSaveHTML, generateHTML, getGlobalsPrint, grunt, i, isAMD, isHTML, isHTMLsaved, len, libBB, libRjsConf, libToSpecPath, mocha_path, ref, requirejs_path, rjsConf, runMochaShell, specPathHTML, specRunners, specRunnersExecuted, specToLibPath, templates, watchesToBlend, writeHTMLSpec;
  if (this.options) { // using @options introduced in "0.7.0-beta.15"
    options = this.options;
  } else {
    if (!_B.isHash(options)) { // support pre "0.7.0-beta.15"
      options = {}; // ignore the `afterBuild` async callback cause of the 3-args signature
    }
  }
  if (!(libBB = specBB.urequire.findBBExecutedBefore(specBB))) {
    err = "The library bundleBuilder is missing:\nYou need to build the 'lib' you want to run the specs against, just before the specs.\nI.e execute something like `$ grunt lib spec`, where `spec` has `afterBuild: require('urequire-ab-specrunner')`";
    throw new Error('`urequire-ab-specrunner`:' + err);
  }
  if (require('semver').lt(libBB.urequire.VERSION, minUrequireVersion)) {
    throw new Error(`Incompatible \`urequire\` version '${libBB.urequire.VERSION}'. You need \`urequire\` version >= '${minUrequireVersion}' for \`urequire-ab-specrunner\` version '${pkg.version}'`);
  }
  grunt = libBB.urequire.grunt; // if running through `grunt-urequire` grunt is set, otherwise undefined
  _B.Logger.addDebugPathLevel('urequire-ab-specrunner', options.debugLevel || 0);
  _title = `lib.target:'${libBB.build.target}', spec.target:'${specBB.build.target}'`;
  // invoke watch
  if (grunt && (!isWatching) && (options.watch || _.any([libBB, specBB], function(bb) {
    return bb.build.watch.enabled === true;
  }))) {
    isWatching = true;
    watchesToBlend = [ // all blended as watch options
      {
        before: `urequire:${libBB.build.target}`
      },
      options.watch,
      specBB.build.watch,
      libBB.build.watch
    ];
    watchesToBlend.debugLevel = options.debugLevel; // not very neat
    require('urequire-ab-grunt-contrib-watch')(err, specBB, watchesToBlend);
  }
  if (!(libBB.build.hasChanged || specBB.build.hasChanged)) {
    if (isWatching) {
      l.ok(`No changes for \`${_title}\` while \`watch\`-ing - not executing.`);
      return When();
    }
  }
  ref = [libBB, specBB];
  // check for errors in either lib or spec bbs
  for (i = 0, len = ref.length; i < len; i++) {
    bb = ref[i];
    if (bb.build.hasErrors) {
      if (options.runOnErrors === true) {
        l.warn(`Executing for \`${_title}\` despite of errors in bundle \`${bb.build.target}\` - cause \`runOnErrors: true\``);
      } else {
        l.er(`Not executing for \`${_title}\` cause of errors in bundle \`${bb.build.target}\``);
        return When();
      }
    }
  }
  l.ok(`Executing for ${_title}.`);
  isAMD = !((libBB.build.template.name === 'combined') && (specBB.build.template.name === 'combined'));
  isHTML = !((libBB.build.template.name === 'nodejs') || (specBB.build.template.name === 'nodejs'));
  if (isHTML) {
    // absolute dependency paths from lib, eg 'bower_components/lodash/lodash.compat', to blend into specs paths
    libRjsConf = libBB.build.calcRequireJsConfig('.', null, true);
    // paths relative to specsBB.build.dstPath, blendedWith lib's paths
    rjsConf = fixPathsForNode(specBB.build.calcRequireJsConfig(null, libRjsConf, ['mocha', 'chai', 'requirejs'], [libBB.bundle.package.name]));
    l.deb(60, `All rjsConf paths, relative to \`specBB.build.dstPath = ${specBB.build.dstPath} \`:\n`, rjsConf.paths);
    requirejs_path = rjsConf.paths.requirejs[0];
    mocha_path = rjsConf.paths.mocha[0];
    chai_path = rjsConf.paths.chai[0];
    if (isAMD) { // paths relative to baseUrl (instead of specs dstPath), which will be set to lib's path
      rjsConf = fixPathsForNode(specBB.build.calcRequireJsConfig(libBB.build.dstPath, libRjsConf, true, [libBB.bundle.package.name]));
    }
    delete rjsConf.paths.mocha;
    delete rjsConf.paths.requirejs;
    l.deb(40, `Final needed only \`require.config.paths\` for ${(isAMD ? "AMD" : "plain <script>")}:\n`, rjsConf.paths);
  }
  specToLibPath = upath.relative(specBB.build.dstPath, libBB.build.dstPath);
  libToSpecPath = upath.relative(libBB.build.dstPath, specBB.build.dstPath);
  // gather globals from options.global, dependencies.rootExports & rjs.shim exports
  getGlobalsPrint = function() {
    var allGLobals, g;
    allGLobals = _.unique(_.filter((_B.arrayize(options.globalsPrint) || []).concat(_.flatten((function() {
      var j, len1, ref1, ref2, ref3, results;
      ref1 = [libBB, specBB];
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        bb = ref1[j];
        results.push(_.map((ref2 = bb.build) != null ? (ref3 = ref2.rjs) != null ? ref3.shim : void 0 : void 0, 'exports').concat(_.reduce(bb.bundle.dependencies.rootExports, (function(allRootExports, re) {
          return allRootExports.concat(re);
        }), [])).concat(_.reduce(bb.bundle.local_nonNode_depsVars, (function(localVars, lv) {
          return localVars.concat(lv);
        }), [])));
      }
      return results;
    })()))));
    if (!_.isEmpty(allGLobals)) {
      l.deb(50, "Discovered ", g = `.globals([${_.map(allGLobals, function(exp) {
        return `'${exp}'`;
      }).join(', ')}])`);
      return g;
    } else {
      return '';
    }
  };
  generateHTML = function() {
    var HTML, addRow, globalsPrint;
    addRow = function(name, lib, spec) {
      return tr(function() {
        td('.tg-70v4', name);
        td('.tg-031e', lib || 'undefined');
        return td('.tg-031e', spec || 'undefined');
      });
    };
    globalsPrint = getGlobalsPrint();
    HTML = teacup.render(function() {
      doctype(5);
      return html(function() {
        var dep, j, k, len1, mod, ref1;
        head(function() {
          meta({
            charset: 'utf-8'
          });
          return title('urequire-ab-specrunner:' + _title);
        });
        body(function() {
          h3(`Auto generated spec runner by \`urequire-ab-specrunner\` v'${pkg.version}`);
          style('text/css', '.tg  {border-collapse:collapse;border-spacing:0;border-color:#aabcfe;}\n  .tg td{font-family:Arial, sans-serif;font-size:14px;padding:3px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#aabcfe;color:#669;background-color:#e8edff;}\n  .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:3px 20px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:#aabcfe;color:#039;background-color:#b9c9fe;}\n  .tg .tg-70v4{background-color:#cbcefb;color:#000000}');
          table('.tg', function() {
            tr(function() {
              td('.tg-70v4', 'Loader');
              return td('.tg-031e', isAMD ? `AMD (RequireJS \`${requirejs_path + '.js'}\`)` : '<script/>');
            });
            tr(function() {
              td('.tg-70v4', '.globals');
              return td('.tg-031e', globalsPrint);
            });
            tr(function() {
              td('.tg-70v4', 'loaded deps');
              return td('.tg-031e', _.keys(rjsConf.paths).join(', '));
            });
            return tr(function() {
              td('.tg-70v4', 'watch');
              return td('.tg-031e', libBB.build.watch.enabled ? "enabled (note: HTML not regenerated)" : 'disabled');
            });
          });
          table('.tg', function() {
            tr(function() {
              th('.tg-031e');
              th('.tg-031e', 'lib');
              return th('.tg-031e', 'spec');
            });
            addRow('build.dstPath', libBB.build.dstPath, specBB.build.dstPath);
            addRow('build.dstMainFilename', libBB.build.dstMainFilename, (specBB.bundle.main || specBB.build.template.name === 'combined') ? specBB.build.dstMainFilename : 'none (all spec files loaded)');
            addRow('build.target', libBB.build.target, specBB.build.target);
            addRow('bundle.name', libBB.bundle.name, specBB.bundle.name);
            return addRow('build.template', libBB.build.template.name, specBB.build.template.name);
          });
          return div('#mocha');
        });
        link({
          rel: 'stylesheet',
          href: mocha_path + '.css'
        });
        // grunt-mocha / phantomjs require mocha & chai as plain <script> (using paths relative to specs dstPath)
        script({
          src: mocha_path + '.js'
        });
        script({
          src: chai_path + '.js'
        });
        if (options.injectCode) {
          script(options.injectCode);
        }
        if (options.injectRaw) {
          raw(options.injectRaw);
        }
        script(`mocha.setup(${(_.isString(options.mochaSetup) ? options.mochaSetup : _B.isHash(options.mochaSetup) ? JSON.stringify(options.mochaSetup, null, 2) : "'bdd'")});`);
        if (isAMD) {
          rjsConf.baseUrl = specToLibPath;
          rjsConf.paths[libBB.bundle.package.name] = upath.trimExt(libBB.build.dstMainFilename);
          rjsConf.paths.libToSpecPath = libToSpecPath;
          l.deb(30, "Final AMD `require.config`:\n", rjsConf);
          script({
            src: requirejs_path + '.js'
          });
          script(`require.config(${JSON.stringify(rjsConf, null, 2)});`);
        } else {
          comment("Loading all deps as <script>, sorted with shim order");
          ref1 = rjsConf.shimSortedDeps;
          // already loaded
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            dep = ref1[j];
            if (dep !== 'chai') {
              script({
                src: rjsConf.paths[dep] + '.js'
              });
            }
          }
          comment("Loading library");
          script({
            src: upath.join(specToLibPath, libBB.build.dstMainFilename)
          });
          comment("Loading specs");
          script({
            src: specBB.build.dstMainFilename // of combined template
          });
        }
        comment(`Invoke \`mocha.run()\` as ${(isAMD ? 'AMD' : 'plain script')}, taking care of phantomjs`);
        return script((isAMD ? `require(['${(specBB.bundle.main || (specBB.build.template.name === 'combined') ? [specBB.build.dstMainFilename] : (function() {
          var ref2, results;
          ref2 = specBB.bundle.modules;
          results = [];
          for (k in ref2) {
            mod = ref2[k];
            results.push(mod.dstFilename);
          }
          return results;
        })()).map(function(f) {
          return upath.join('libToSpecPath/', upath.trimExt(f));
        }).join("', '")}'], function() {` : 'if (!window.PHANTOMJS) {') + `\n\n  if (window.mochaPhantomJS) {\n    mochaPhantomJS.run()${globalsPrint};\n  } else {\n    mocha.run()${globalsPrint};\n  }\n}` + (isAMD ? ");" : ''));
      });
    });
    if (options.tidy) {
      return tidyP(HTML);
    } else {
      return When(HTML);
    }
  };
  specPathHTML = `${specBB.build.dstPath}/urequire-ab-specrunner-${(isAMD ? 'AMD' : 'script')}-${libBB.build.target}_${specBB.build.target}.html`;
  writeHTMLSpec = function(htmlText) {
    l.deb(80, `Saving spec HTML as \`${specPathHTML}\``);
    return fsp.outputFile(specPathHTML, htmlText);
  };
  isHTMLsaved = false;
  generateAndSaveHTML = function() {
    if (isHTMLsaved) {
      return When();
    } else {
      l.deb(50, `Generating spec HTML & saving as \`${specPathHTML}\``);
      return When.pipeline([generateHTML, writeHTMLSpec]).then(function() {
        l.deb(80, `Saved spec HTML to \`${specPathHTML}\``);
        return isHTMLsaved = true;
      });
    }
  };
  runMochaShell = function(cmd, filename) {
    var mochaParams;
    mochaParams = _.filter(((options.mochaOptions || '') + ' ' + filename).split(/\s/));
    l.deb(30, `Running shell \`${cmd} ${mochaParams.join(' ')}\``);
    if (!options.exec) { //default
      if (process.platform === "win32") { // solves ENOENT http://stackoverflow.com/questions/17516772/using-nodejss-spawn-causes-unknown-option-and-error-spawn-enoent-err
        cmd = cmd.replace(/\//g, '\\') + '.cmd';
      }
      l.ok(`spawn-ing \`${cmd} ${mochaParams.join(' ')}\``);
      return When.promise(function(resolve, reject) {
        var cp;
        cp = spawn(cmd, mochaParams);
        cp.stdout.pipe(process.stdout);
        cp.stderr.pipe(process.stderr);
        return cp.on('close', function(code) {
          if (code === 0) {
            return resolve();
          } else {
            return reject(new Error(`\`urequire-ab-specrunner\` error: \`${cmd}\` returned error code ${code}`));
          }
        });
      });
    } else {
      l.ok(`exec-ing \`${cmd} ${mochaParams.join(' ')}\``);
      cmd = `${cmd} ${mochaParams.join(' ')}`;
      return execP(cmd).then(function(res) {
        return l.log(res[0]);
      }, function(err) {
        return l.err(err);
      });
    }
  };
  specRunners = {
    'grunt-mocha': {
      reject: ['nodejs'],
      run: When.lift(function() {
        if (grunt) {
          return generateAndSaveHTML().then(function() {
            var mocha, task;
            mocha = {};
            task = `${libBB.build.target}_${specBB.build.target}`;
            mocha[task] = {
              src: [specPathHTML]
            };
            if (!isAMD) { // @todo: add grunt-mocha options ?
              mocha[task].options = {
                run: true
              };
            }
            grunt.config.merge({
              'mocha': mocha
            });
            return grunt.task.run(`mocha:${task}`);
          });
        } else {
          throw new Error("`urequire-ab-specrunner` error: Can't run specRunner `grunt-mocha` - not running through `grunt` & `grunt-urequire` >= v0.7.0");
        }
      })
    },
    'mocha-phantomjs': {
      reject: ['nodejs'],
      run: function() {
        return generateAndSaveHTML().then(function() {
          return runMochaShell('mocha-phantomjs', specPathHTML);
        });
      }
    },
    'mocha-cli': {
      reject: ['AMD'],
      run: function() {
        var pkgJsonPath;
        pkgJsonPath = `${specBB.build.dstPath}/node_modules/${libBB.bundle.package.name}/package.json`;
        l.deb(50, `Saving a fake module of lib into spec's dstPath in \`${pkgJsonPath}\``);
        return fsp.outputFile(pkgJsonPath, JSON.stringify({
          "name": libBB.bundle.package.name,
          "description": `A fake module for \`${libBB.bundle.package.name}\` generated by \`urequire-ab-specrunner\` used by its specs.`,
          "main": upath.join(libBB.bundle.package.name.split('/').map(function() {
            return '../';
          }).join(''), '../', specToLibPath, libBB.build.dstMainFilename) // back from `package.name` potentialy many paths (eg 'mycompany/mypackage') // back from node_modules
        }, null, 2), 'utf8').then(function() {
          return runMochaShell('./node_modules/.bin/mocha', specBB.bundle.main || (specBB.build.template.name === 'combined') ? specBB.build.dstMainFilepath : `${specBB.build.dstPath} --recursive`);
        });
      }
    }
  };
  templates = ['UMD', 'UMDplain', 'AMD', 'nodejs', 'combined'];
  specRunnersExecuted = 0;
  return When.each(_B.arrayize(options.specRunners || ['mocha-cli', 'mocha-phantomjs']), function(name) {
    var j, len1, ref1, ref2, sr;
    if (!(sr = specRunners[name])) {
      throw new Error(`\`urequire-ab-specrunner\` error: unknown mocha specRunner '${name}' - exiting.`);
    } else {
      ref1 = [libBB, specBB];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        bb = ref1[j];
        if (ref2 = bb.build.template.name, indexOf.call(sr.reject || [], ref2) >= 0) {
          if (indexOf.call(_B.arrayize(options.specRunners), name) >= 0) {
            throw new Error(`\`urequire-ab-specrunner\` error: incompatible runtime - can't run requested specRunner \`${name}\` with bundle \`${bb.build.target}\` build with template \`${bb.build.template.name}\`\n  * You can use any template among ${l.prettify(_.reject(templates, function(t) {
              return indexOf.call(sr.reject, t) >= 0;
            }))}\n  * Use the default \`specRunners\` or any different one among ${l.prettify(_.keys(_.pick(specRunners, function(spr) {
              var ref3;
              return ref3 = !bb.build.template.name, indexOf.call(spr.reject || [], ref3) >= 0;
            })))}`);
          }
          l.debug(80, `Ignoring incompatible runtime specRunner \`${name}\` for  bundle \`${bb.build.target}\` build with template \`${bb.build.template.name
          // silently ignore / dont run if not requested by user
}\``);
          return;
        }
      }
      l.debug(80, `Invoking specRunner \`${name}\` for lib \`${libBB.build.target}\` against spec \`${specBB.build.target}\``);
      specRunnersExecuted++;
      return sr.run();
    }
  }).then(function() {
    if (specRunnersExecuted === 0) {
      return l.warn("No compatible specRunners were found to execute - check your templates compatibility (eg 'nodejs' + 'AMD' work go together).");
    } else {
      return l.ok(`Finished executing ${specRunnersExecuted} compatible specRunners.`);
    }
  });
};

// allow mocha, chai & requirejs to work from both node_modules & bower_components
fixPathsForNode = function(rjsCfg) {
  if (rjsCfg.paths.mocha) {
    rjsCfg.paths.mocha = _.uniq(_.map(rjsCfg.paths.mocha, function(p) {
      return upath.dirname(p) + '/mocha';
    }));
  }
  if (rjsCfg.paths.chai) {
    rjsCfg.paths.chai = _.uniq(_.map(rjsCfg.paths.chai, function(p) {
      return upath.dirname(p) + '/chai';
    }));
  }
  if (rjsCfg.paths.requirejs) {
    rjsCfg.paths.requirejs = _.uniq(_.map(rjsCfg.paths.requirejs, function(p) {
      return p.replace('bin/r', 'require');
    }));
  }
  return rjsCfg;
};

// passing options
specRunner.options = function(opts) {
  return function(err, bb) {
    return specRunner(err, bb, opts); // promise-based fn signature must have 2 args
  };
};
